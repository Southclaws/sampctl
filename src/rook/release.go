package rook

import (
	"context"
	"fmt"
	"io/ioutil"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"github.com/Masterminds/semver"
	"github.com/google/go-github/github"
	"github.com/pkg/errors"
	"gopkg.in/AlecAivazis/survey.v1"
	"gopkg.in/src-d/go-git.v4"
	"gopkg.in/src-d/go-git.v4/config"
	"gopkg.in/src-d/go-git.v4/plumbing"
	"gopkg.in/src-d/go-git.v4/plumbing/object"
	"gopkg.in/src-d/go-git.v4/plumbing/transport"

	"github.com/Southclaws/sampctl/print"
	"github.com/Southclaws/sampctl/types"
	"github.com/Southclaws/sampctl/versioning"
)

const versionIncTemplate = `// This file was generated by "sampctl package release"
// DO NOT EDIT THIS FILE MANUALLY!
// To update the version number for a new release, run "sampctl package release"

#define %s_VERSION_MAJOR (%d)
#define %s_VERSION_MINOR (%d)
#define %s_VERSION_PATCH (%d)
`

// Release is an interactive release tool for package versioning
func Release(ctx context.Context, gh *github.Client, auth transport.AuthMethod, pkg types.Package) (err error) {
	repo, err := git.PlainOpen(pkg.LocalPath)
	if err != nil {
		return errors.Wrap(err, "failed to read package as git repository")
	}

	_, err = repo.Head()
	if err != nil {
		print.Erro("failed to get repo HEAD reference, if this is a new repo, you need to make at least one commit")
		return
	}

	tags, err := versioning.GetRepoSemverTags(repo)
	if err != nil {
		return errors.Wrap(err, "failed to get semver tags")
	}
	sort.Sort(sort.Reverse(tags))

	var questions []*survey.Question
	var answers struct {
		Version      string
		Generate     bool
		Distribution bool
		GitHub       bool
	}

	if len(tags) == 0 {
		questions = []*survey.Question{
			{
				Name: "Version",
				Prompt: &survey.Select{
					Message: "New Project Version",
					Options: []string{
						"0.0.1: Unstable prototype",
						"0.1.0: Stable prototype but subject to change",
						"1.0.0: Stable release, API won't change",
						"x.y.z: Enter a custom initial version",
					},
				},
				Validate: survey.Required,
			},
		}
	} else {
		var latest = tags[0]

		print.Info("Latest version:", latest.Version)

		bumpPatch := latest.Version.IncPatch()
		bumpMinor := latest.Version.IncMinor()
		bumpMajor := latest.Version.IncMajor()

		questions = []*survey.Question{
			{
				Name: "Version",
				Prompt: &survey.Select{
					Message: "Select Version Bump",
					Options: []string{
						fmt.Sprintf("%s: I made backwards-compatible bug fixes", bumpPatch.String()),
						fmt.Sprintf("%s: I added functionality in a backwards-compatible manner", bumpMinor.String()),
						fmt.Sprintf("%s: I made incompatible API changes", bumpMajor.String()),
					},
				},
				Validate: survey.Required,
			},
		}
	}

	questions = append(questions, &survey.Question{
		Name: "Generate",
		Prompt: &survey.Confirm{
			Message: fmt.Sprintf("Generate/update `%s`?", packageSlug(pkg.Repo)+"_version.inc"),
			Default: true,
		},
	})

	// questions = append(questions, &survey.Question{
	// 	Name: "Distribution",
	// 	Prompt: &survey.Confirm{
	// 		Message: "Create Distribution Release?",
	// 		Default: false,
	// 	},
	// })

	questions = append(questions, &survey.Question{
		Name: "GitHub",
		Prompt: &survey.Confirm{
			Message: "Create GitHub Release? (requires `github_token` token to be set in `~/.samp/config.json`)",
			Default: false,
		},
	})

	err = survey.Ask(questions, &answers)
	if err != nil {
		return errors.Wrap(err, "failed to open wizard")
	}
	versionText := strings.Split(answers.Version, ":")[0]

	if versionText == "x.y.z" {
		var custom struct{ Custom string }
		err = survey.Ask([]*survey.Question{{
			Name: "Custom",
			Prompt: &survey.Input{
				Message: "Enter custom semantic version number",
				Default: "0.1.0",
			},
			Validate: func(ans interface{}) (err error) {
				if _, err = semver.NewVersion(ans.(string)); err != nil {
					return err
				}
				return
			},
		}}, &custom)
		if err != nil {
			return errors.Wrap(err, "failed to open wizard")
		}
		versionText = custom.Custom
	}

	newVersion, err := semver.NewVersion(versionText)
	if err != nil {
		return errors.Wrap(err, "failed to create version from result")
	}

	versionFile, err := generateVersionInc(pkg, newVersion)
	if err != nil {
		return errors.Wrap(err, "failed to generate version.inc")
	}

	print.Info("New version:", newVersion)

	// commit the new version file and tag the commit with the version number
	wt, err := repo.Worktree()
	if err != nil {
		return errors.Wrap(err, "failed to get worktree")
	}
	_, err = wt.Add(versionFile)
	if err != nil {
		return errors.Wrap(err, "failed to add versionfile to worktree")
	}
	hash, err := wt.Commit("sampctl package release: "+newVersion.String(), &git.CommitOptions{
		Author: &object.Signature{
			Name:  "sampctl",
			Email: "null",
			When:  time.Now(),
		},
	})
	if err != nil {
		return errors.Wrap(err, "failed to create new commit for release")
	}
	refName := plumbing.ReferenceName("refs/tags/" + newVersion.String())
	ref := plumbing.NewHashReference(refName, hash)
	err = repo.Storer.SetReference(ref)
	if err != nil {
		return
	}

	print.Info("Pushing", newVersion, "to remote")
	err = repo.Push(&git.PushOptions{
		RefSpecs: []config.RefSpec{config.RefSpec("refs/tags/*:refs/tags/*")},
		Auth:     auth,
	})
	if err != nil {
		if err.Error() == "authentication required" {
			print.Erro("Please set up either Git SSH or enter your username/password into ~/.samp/config.json")
		} else if err.Error() == "already up-to-date" {
			err = nil
		}
		return errors.Wrap(err, "failed to push")
	}

	if answers.GitHub {
		// todo: generate changelog

		print.Info("Creating release for", newVersion)
		versionString := newVersion.String()
		_, _, err := gh.Repositories.CreateRelease(ctx, pkg.User, pkg.Repo, &github.RepositoryRelease{
			TagName: &versionString,
			Name:    &versionString,
			Draft:   &[]bool{true}[0],
		})
		if err != nil {
			print.Erro("Please set `github_token` to a GitHub API token in `~/.samp/config.json`")
			return errors.Wrap(err, "failed to create release")
		}

		print.Info("Released at:", fmt.Sprintf("https://github.com/%s/%s/releases", pkg.User, pkg.Repo))
	}

	// todo: zip the package in a `pawno/include` style
	// possibly include dependencies too
	// if answers.Distribution {
	// }

	return nil
}

func generateVersionInc(pkg types.Package, version *semver.Version) (filename string, err error) {
	filename = packageSlug(pkg.Repo) + "_version.inc"
	err = ioutil.WriteFile(
		filepath.Join(pkg.LocalPath, filename),
		[]byte(generateVersionIncString(pkg.Repo, version)),
		0600,
	)
	return
}

func generateVersionIncString(name string, version *semver.Version) (result string) {
	packageName := strings.ToUpper(packageSlug(name))
	result = fmt.Sprintf(versionIncTemplate,
		packageName,
		version.Major(),
		packageName,
		version.Minor(),
		packageName,
		version.Patch(),
	)
	return
}

func packageSlug(name string) (slug string) {
	replacer := strings.NewReplacer(
		"-", "_",
		".", "_",
	)
	return replacer.Replace(name)
}
