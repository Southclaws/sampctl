package rook

import (
	"archive/zip"
	"fmt"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/Masterminds/semver"
	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/config"
	"github.com/go-git/go-git/v5/plumbing"
	"github.com/go-git/go-git/v5/plumbing/object"
	"github.com/go-git/go-git/v5/plumbing/storer"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/Southclaws/sampctl/src/pkg/infrastructure/versioning"
	"github.com/Southclaws/sampctl/src/pkg/package/pawnpackage"
)

func Test_generateVersionIncString(t *testing.T) {
	type args struct {
		repo    string
		version string
	}
	tests := []struct {
		name       string
		args       args
		wantResult string
	}{
		{
			"1",
			args{"samp-ini", "1.1.1"},
			`// This file was generated by "sampctl package release"
// DO NOT EDIT THIS FILE MANUALLY!
// To update the version number for a new release, run "sampctl package release"

#define SAMP_INI_VERSION_MAJOR (1)
#define SAMP_INI_VERSION_MINOR (1)
#define SAMP_INI_VERSION_PATCH (1)
`,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ver, _ := semver.NewVersion(tt.args.version)
			if gotResult := generateVersionIncString(tt.args.repo, ver); gotResult != tt.wantResult {
				t.Errorf("generateVersionIncString() = %v, want %v", gotResult, tt.wantResult)
			}
		})
	}
}

func TestReleaseWithoutUserRepo(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test in short mode")
	}

	tmpDir, err := os.MkdirTemp("", "sampctl-release-test-*")
	require.NoError(t, err)
	defer os.RemoveAll(tmpDir)

	repo, err := git.PlainInit(tmpDir, false)
	require.NoError(t, err)

	wt, err := repo.Worktree()
	require.NoError(t, err)

	dummyFile := filepath.Join(tmpDir, "test.txt")
	err = os.WriteFile(dummyFile, []byte("test"), 0o644)
	require.NoError(t, err)

	_, err = wt.Add("test.txt")
	require.NoError(t, err)

	_, err = wt.Commit("initial commit", &git.CommitOptions{
		Author: &object.Signature{
			Name:  "Test User",
			Email: "test@example.com",
			When:  time.Now(),
		},
	})
	require.NoError(t, err)

	pkg := pawnpackage.Package{
		LocalPath: tmpDir,
	}
	pkg.User = ""
	pkg.Repo = ""

	if pkg.User == "" || pkg.Repo == "" {
		validationErr := assert.AnError
		assert.Error(t, validationErr, "Expected error when User and Repo are empty")
	}
}

func TestReleaseWithDirtyWorktree(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test in short mode")
	}

	tmpDir, err := os.MkdirTemp("", "sampctl-release-test-*")
	require.NoError(t, err)
	defer os.RemoveAll(tmpDir)

	repo, err := git.PlainInit(tmpDir, false)
	require.NoError(t, err)

	wt, err := repo.Worktree()
	require.NoError(t, err)

	dummyFile := filepath.Join(tmpDir, "test.txt")
	err = os.WriteFile(dummyFile, []byte("test"), 0o644)
	require.NoError(t, err)

	_, err = wt.Add("test.txt")
	require.NoError(t, err)

	_, err = wt.Commit("initial commit", &git.CommitOptions{
		Author: &object.Signature{
			Name:  "Test User",
			Email: "test@example.com",
			When:  time.Now(),
		},
	})
	require.NoError(t, err)

	dirtyFile := filepath.Join(tmpDir, "uncommitted.txt")
	err = os.WriteFile(dirtyFile, []byte("uncommitted"), 0o644)
	require.NoError(t, err)

	status, err := wt.Status()
	require.NoError(t, err)
	assert.False(t, status.IsClean(), "Worktree should be dirty")

	if !status.IsClean() {
		validationErr := assert.AnError
		assert.Error(t, validationErr, "Expected error when worktree is dirty")
	}
}

func TestGenerateVersionIncRespected(t *testing.T) {
	tests := []struct {
		name           string
		generateOption bool
		shouldGenerate bool
	}{
		{
			name:           "Generate enabled should create version file",
			generateOption: true,
			shouldGenerate: true,
		},
		{
			name:           "Generate disabled should not create version file",
			generateOption: false,
			shouldGenerate: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tmpDir, err := os.MkdirTemp("", "sampctl-version-test-*")
			require.NoError(t, err)
			defer os.RemoveAll(tmpDir)

			pkg := pawnpackage.Package{
				LocalPath: tmpDir,
			}
			pkg.Repo = "test-package"

			version := semver.MustParse("1.2.3")

			if tt.generateOption {
				versionFile, err := generateVersionInc(pkg, version)
				require.NoError(t, err)

				fullPath := filepath.Join(tmpDir, versionFile)
				assert.FileExists(t, fullPath, "Version file should be created when Generate is true")

				content, err := os.ReadFile(fullPath)
				require.NoError(t, err)
				assert.Contains(t, string(content), "TEST_PACKAGE_VERSION_MAJOR (1)")
				assert.Contains(t, string(content), "TEST_PACKAGE_VERSION_MINOR (2)")
				assert.Contains(t, string(content), "TEST_PACKAGE_VERSION_PATCH (3)")
			} else {
				expectedPath := filepath.Join(tmpDir, "version.inc")
				_, err := os.Stat(expectedPath)
				assert.True(t, os.IsNotExist(err), "Version file should not exist when Generate is false")
			}
		})
	}
}

func TestPackageSlug(t *testing.T) {
	tests := []struct {
		name     string
		repoName string
		expected string
	}{
		{
			name:     "Simple name",
			repoName: "test-package",
			expected: "test_package",
		},
		{
			name:     "Name with dots",
			repoName: "my.awesome.lib",
			expected: "my_awesome_lib",
		},
		{
			name:     "Name with spaces (not replaced)",
			repoName: "my package",
			expected: "my package",
		},
		{
			name:     "Name with mixed case (preserved)",
			repoName: "MyAwesomePackage",
			expected: "MyAwesomePackage",
		},
		{
			name:     "Name with underscores (unchanged)",
			repoName: "my_package_name",
			expected: "my_package_name",
		},
		{
			name:     "Name with hyphens and dots",
			repoName: "my-package.name",
			expected: "my_package_name",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := packageSlug(tt.repoName)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestGitConfigPathError(t *testing.T) {
	configPath := filepath.Join(os.Getenv("HOME"), ".samp", "config.json")
	assert.NotEmpty(t, configPath)
	assert.Contains(t, configPath, "config.json")
}

func TestGitPushRefSpecs(t *testing.T) {
	branchName := "main"
	expectedCommitRefSpec := config.RefSpec("refs/heads/" + branchName + ":refs/heads/" + branchName)
	expectedTagsRefSpec := config.RefSpec("refs/tags/*:refs/tags/*")

	assert.Equal(t, "refs/heads/main:refs/heads/main", string(expectedCommitRefSpec))
	assert.Equal(t, "refs/tags/*:refs/tags/*", string(expectedTagsRefSpec))
}

type MockGitHubClient struct {
	CreateReleaseCalled bool
	CreateReleaseError  error
	User                string
	Repo                string
}

func TestGitHubReleaseValidation(t *testing.T) {
	tests := []struct {
		name        string
		user        string
		repo        string
		shouldError bool
	}{
		{
			name:        "Valid user and repo",
			user:        "testuser",
			repo:        "testrepo",
			shouldError: false,
		},
		{
			name:        "Missing user",
			user:        "",
			repo:        "testrepo",
			shouldError: true,
		},
		{
			name:        "Missing repo",
			user:        "testuser",
			repo:        "",
			shouldError: true,
		},
		{
			name:        "Missing both",
			user:        "",
			repo:        "",
			shouldError: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			pkg := pawnpackage.Package{}
			pkg.User = tt.user
			pkg.Repo = tt.repo

			if pkg.User == "" || pkg.Repo == "" {
				validationErr := assert.AnError
				if tt.shouldError {
					assert.Error(t, validationErr, "Expected error for invalid user/repo")
				}
			} else {
				if !tt.shouldError {
					assert.NotEmpty(t, pkg.User)
					assert.NotEmpty(t, pkg.Repo)
				}
			}
		})
	}
}

func TestErrorMessageFormat(t *testing.T) {
	tests := []struct {
		name            string
		errorType       string
		expectedPhrases []string
	}{
		{
			name:      "Git authentication error",
			errorType: "auth",
			expectedPhrases: []string{
				"Git authentication failed",
				"Set up SSH keys",
				"git credentials",
				"config.json",
			},
		},
		{
			name:      "GitHub token error",
			errorType: "github",
			expectedPhrases: []string{
				"GitHub release",
				"GitHub API token",
				"config.json",
				"repo' scope",
				"write access",
			},
		},
		{
			name:      "Missing user/repo error",
			errorType: "validation",
			expectedPhrases: []string{
				"user and repo fields",
				"pawn.json",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			for _, phrase := range tt.expectedPhrases {
				assert.NotEmpty(t, phrase, "Error message should contain helpful phrase")
			}
		})
	}
}

func TestCleanWorktreeCheck(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test in short mode")
	}

	tmpDir, err := os.MkdirTemp("", "sampctl-worktree-test-*")
	require.NoError(t, err)
	defer os.RemoveAll(tmpDir)

	repo, err := git.PlainInit(tmpDir, false)
	require.NoError(t, err)

	wt, err := repo.Worktree()
	require.NoError(t, err)

	status, err := wt.Status()
	require.NoError(t, err)
	assert.True(t, status.IsClean(), "Empty worktree should be clean")

	testFile := filepath.Join(tmpDir, "test.txt")
	err = os.WriteFile(testFile, []byte("content"), 0o644)
	require.NoError(t, err)

	_, err = wt.Add("test.txt")
	require.NoError(t, err)

	_, err = wt.Commit("test commit", &git.CommitOptions{
		Author: &object.Signature{
			Name:  "Test",
			Email: "test@test.com",
			When:  time.Now(),
		},
	})
	require.NoError(t, err)

	status, err = wt.Status()
	require.NoError(t, err)
	assert.True(t, status.IsClean(), "Worktree should be clean after commit")

	err = os.WriteFile(testFile, []byte("modified"), 0o644)
	require.NoError(t, err)

	status, err = wt.Status()
	require.NoError(t, err)
	assert.False(t, status.IsClean(), "Worktree should be dirty after modification")
}

func setupTestRepository(t *testing.T) (string, *git.Repository, func()) {
	tmpDir, err := os.MkdirTemp("", "sampctl-integration-*")
	require.NoError(t, err)

	repo, err := git.PlainInit(tmpDir, false)
	require.NoError(t, err)

	wt, err := repo.Worktree()
	require.NoError(t, err)

	dummyFile := filepath.Join(tmpDir, "README.md")
	err = os.WriteFile(dummyFile, []byte("# Test Package"), 0o644)
	require.NoError(t, err)

	_, err = wt.Add("README.md")
	require.NoError(t, err)

	_, err = wt.Commit("initial commit", &git.CommitOptions{
		Author: &object.Signature{
			Name:  "Test User",
			Email: "test@example.com",
			When:  time.Now(),
		},
	})
	require.NoError(t, err)

	cleanup := func() {
		os.RemoveAll(tmpDir)
	}

	return tmpDir, repo, cleanup
}

func TestReleaseIntegration(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test in short mode")
	}

	tmpDir, repo, cleanup := setupTestRepository(t)
	defer cleanup()

	pkg := pawnpackage.Package{
		LocalPath: tmpDir,
	}
	pkg.User = "testuser"
	pkg.Repo = "testrepo"

	wt, err := repo.Worktree()
	require.NoError(t, err)
	status, err := wt.Status()
	require.NoError(t, err)
	assert.True(t, status.IsClean(), "Initial worktree should be clean")

	version := semver.MustParse("1.0.0")
	versionFile, err := generateVersionInc(pkg, version)
	require.NoError(t, err)

	fullPath := filepath.Join(tmpDir, versionFile)
	assert.FileExists(t, fullPath)

	content, err := os.ReadFile(fullPath)
	require.NoError(t, err)
	assert.Contains(t, string(content), "TESTREPO_VERSION_MAJOR (1)")
	assert.Contains(t, string(content), "TESTREPO_VERSION_MINOR (0)")
	assert.Contains(t, string(content), "TESTREPO_VERSION_PATCH (0)")

	slug := packageSlug("testrepo")
	assert.Equal(t, "testrepo", slug)

	slug = packageSlug("test-repo-name")
	assert.Equal(t, "test_repo_name", slug)
}

func BenchmarkPackageSlug(b *testing.B) {
	testCases := []string{
		"simple",
		"test-package",
		"my.awesome.library",
		"VeryLongPackageNameWithManyCharacters",
	}

	for _, tc := range testCases {
		b.Run(tc, func(b *testing.B) {
			for i := 0; i < b.N; i++ {
				packageSlug(tc)
			}
		})
	}
}

func TestGenerateChangelog(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test in short mode")
	}

	tests := []struct {
		name            string
		commits         []string
		tags            []string
		expectedPhrases []string
	}{
		{
			name: "Initial release with no previous tags",
			commits: []string{
				"Add initial feature",
				"Fix bug in parser",
				"Update documentation",
			},
			tags: []string{},
			expectedPhrases: []string{
				"Initial Release",
				"Add initial feature",
				"Fix bug in parser",
				"Update documentation",
			},
		},
		{
			name: "Release with previous tag",
			commits: []string{
				"v1.0.0: Previous release",
				"Add new feature",
				"Improve performance",
			},
			tags: []string{"1.0.0"},
			expectedPhrases: []string{
				"Changes since 1.0.0",
				"Add new feature",
				"Improve performance",
			},
		},
		{
			name: "Release with merge commits (should be filtered)",
			commits: []string{
				"Add feature A",
				"Merge pull request #123",
				"Fix issue B",
				"Merge branch 'dev' into main",
			},
			tags: []string{},
			expectedPhrases: []string{
				"Add feature A",
				"Fix issue B",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tmpDir, err := os.MkdirTemp("", "changelog-test-*")
			require.NoError(t, err)
			defer os.RemoveAll(tmpDir)

			repo, err := git.PlainInit(tmpDir, false)
			require.NoError(t, err)

			wt, err := repo.Worktree()
			require.NoError(t, err)

			for i, commitMsg := range tt.commits {
				dummyFile := filepath.Join(tmpDir, fmt.Sprintf("file%d.txt", i))
				err = os.WriteFile(dummyFile, []byte(commitMsg), 0o644)
				require.NoError(t, err)

				_, err = wt.Add(filepath.Base(dummyFile))
				require.NoError(t, err)

				_, err = wt.Commit(commitMsg, &git.CommitOptions{
					Author: &object.Signature{
						Name:  "Test Author",
						Email: "test@example.com",
						When:  time.Now().Add(time.Duration(i) * time.Hour),
					},
				})
				require.NoError(t, err)
			}

			var versionedTags versioning.VersionedTags
			for _, tagVersion := range tt.tags {
				v := semver.MustParse(tagVersion)

				commits, err := repo.CommitObjects()
				require.NoError(t, err)

				err = commits.ForEach(func(c *object.Commit) error {
					if c.Message == "v"+tagVersion+": Previous release" || c.Message == tagVersion {
						ref := plumbing.NewHashReference(plumbing.ReferenceName("refs/tags/"+tagVersion), c.Hash)
						versionedTags = append(versionedTags, versioning.VersionedTag{
							Ref:     ref,
							Name:    tagVersion,
							Version: v,
						})
						return storer.ErrStop
					}
					return nil
				})
				require.NoError(t, err)
			}

			newVersion := semver.MustParse("1.1.0")
			changelog, err := generateChangelog(repo, versionedTags, newVersion)
			require.NoError(t, err)
			assert.NotEmpty(t, changelog)

			for _, phrase := range tt.expectedPhrases {
				assert.Contains(t, changelog, phrase, "Changelog should contain: "+phrase)
			}

			if tt.name == "Release with merge commits (should be filtered)" {
				assert.NotContains(t, changelog, "Merge pull request")
				assert.NotContains(t, changelog, "Merge branch")
			}
		})
	}
}

func TestCreateReleaseArchive(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test in short mode")
	}

	tests := []struct {
		name               string
		files              map[string]string
		includePath        string
		expectInArchive    []string
		expectNotInArchive []string
	}{
		{
			name: "Basic package with .inc files",
			files: map[string]string{
				"mylib.inc":  "#define MY_LIB_VERSION 1",
				"helper.inc": "stock MyHelper() {}",
				"README.md":  "# My Library",
				"test.pwn":   "main() {}",
				"build.log":  "Build output",
			},
			includePath: "",
			expectInArchive: []string{
				"pawno/include/mylib.inc",
				"pawno/include/helper.inc",
				"pawno/include/README.md",
				"pawno/include/test.pwn",
			},
			expectNotInArchive: []string{
				"build.log",
			},
		},
		{
			name: "Package with custom include path",
			files: map[string]string{
				"include/mylib.inc": "#define VERSION 1",
				"include/utils.inc": "stock Utils() {}",
				"src/main.pwn":      "main() {}",
				"include/LICENSE":   "MIT License",
			},
			includePath: "include",
			expectInArchive: []string{
				"pawno/include/include/mylib.inc",
				"pawno/include/include/utils.inc",
				"pawno/include/include/LICENSE",
			},
			expectNotInArchive: []string{
				"src/main.pwn",
			},
		},
		{
			name: "Package with subdirectories",
			files: map[string]string{
				"core/main.inc":  "#define CORE",
				"core/utils.inc": "stock Utils() {}",
				"data/types.inc": "enum E_DATA {}",
				"LICENSE.md":     "MIT",
				"random.txt":     "Not included",
			},
			includePath: "",
			expectInArchive: []string{
				"pawno/include/core/main.inc",
				"pawno/include/core/utils.inc",
				"pawno/include/data/types.inc",
				"pawno/include/LICENSE.md",
			},
			expectNotInArchive: []string{
				"random.txt",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tmpDir, err := os.MkdirTemp("", "archive-test-*")
			require.NoError(t, err)
			defer os.RemoveAll(tmpDir)

			for path, content := range tt.files {
				fullPath := filepath.Join(tmpDir, path)
				err := os.MkdirAll(filepath.Dir(fullPath), 0o755)
				require.NoError(t, err)
				err = os.WriteFile(fullPath, []byte(content), 0o644)
				require.NoError(t, err)
			}

			pkg := pawnpackage.Package{
				LocalPath:   tmpDir,
				IncludePath: tt.includePath,
			}
			pkg.Repo = "test-package"

			version := semver.MustParse("1.0.0")
			archivePath, err := createReleaseArchive(pkg, version)
			require.NoError(t, err)
			assert.NotEmpty(t, archivePath)
			assert.FileExists(t, archivePath)

			expectedName := "test-package-1.0.0.zip"
			assert.Equal(t, expectedName, filepath.Base(archivePath))

			archiveFile, err := os.Open(archivePath)
			require.NoError(t, err)
			defer archiveFile.Close()

			stat, err := archiveFile.Stat()
			require.NoError(t, err)

			reader, err := zip.NewReader(archiveFile, stat.Size())
			require.NoError(t, err)

			var archiveFiles []string
			for _, f := range reader.File {
				archiveFiles = append(archiveFiles, f.Name)
			}

			for _, expected := range tt.expectInArchive {
				assert.Contains(t, archiveFiles, expected, "Archive should contain: "+expected)
			}

			for _, notExpected := range tt.expectNotInArchive {
				for _, archiveFile := range archiveFiles {
					assert.NotContains(t, archiveFile, filepath.Base(notExpected),
						"Archive should not contain: "+notExpected)
				}
			}

			assert.NotEmpty(t, archiveFiles, "Archive should not be empty")
		})
	}
}

func TestFormatBytes(t *testing.T) {
	tests := []struct {
		name     string
		bytes    int64
		expected string
	}{
		{"Small file", 512, "512 B"},
		{"1 KB", 1024, "1.0 KiB"},
		{"10 KB", 10240, "10.0 KiB"},
		{"1 MB", 1048576, "1.0 MiB"},
		{"2.5 MB", 2621440, "2.5 MiB"},
		{"1 GB", 1073741824, "1.0 GiB"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := formatBytes(tt.bytes)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestChangelogExcludesReleaseCommits(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test in short mode")
	}

	tmpDir, err := os.MkdirTemp("", "changelog-filter-test-*")
	require.NoError(t, err)
	defer os.RemoveAll(tmpDir)

	repo, err := git.PlainInit(tmpDir, false)
	require.NoError(t, err)

	wt, err := repo.Worktree()
	require.NoError(t, err)

	commits := []string{
		"Add feature X",
		"sampctl package release: 1.0.0",
		"Fix bug Y",
		"Merge pull request #456 from user/branch",
		"Add feature Z",
	}

	for i, commitMsg := range commits {
		dummyFile := filepath.Join(tmpDir, fmt.Sprintf("file%d.txt", i))
		err = os.WriteFile(dummyFile, []byte("content"), 0o644)
		require.NoError(t, err)

		_, err = wt.Add(filepath.Base(dummyFile))
		require.NoError(t, err)

		_, err = wt.Commit(commitMsg, &git.CommitOptions{
			Author: &object.Signature{
				Name:  "Test",
				Email: "test@test.com",
				When:  time.Now().Add(time.Duration(i) * time.Hour),
			},
		})
		require.NoError(t, err)
	}

	newVersion := semver.MustParse("2.0.0")
	changelog, err := generateChangelog(repo, versioning.VersionedTags{}, newVersion)
	require.NoError(t, err)

	assert.Contains(t, changelog, "Add feature X")
	assert.Contains(t, changelog, "Fix bug Y")
	assert.Contains(t, changelog, "Add feature Z")

	assert.NotContains(t, changelog, "sampctl package release")
	assert.NotContains(t, changelog, "Merge pull request")
}
