package rook

import (
	"archive/zip"
	"context"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"github.com/Masterminds/semver"
	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/config"
	"github.com/go-git/go-git/v5/plumbing"
	"github.com/go-git/go-git/v5/plumbing/object"
	"github.com/go-git/go-git/v5/plumbing/storer"
	"github.com/go-git/go-git/v5/plumbing/transport"
	"github.com/google/go-github/github"
	"github.com/pkg/errors"
	"gopkg.in/AlecAivazis/survey.v1"

	"github.com/Southclaws/sampctl/src/pkg/infrastructure/print"
	"github.com/Southclaws/sampctl/src/pkg/infrastructure/util"
	"github.com/Southclaws/sampctl/src/pkg/infrastructure/versioning"
	"github.com/Southclaws/sampctl/src/pkg/package/pawnpackage"
)

const versionIncTemplate = `// This file was generated by "sampctl package release"
// DO NOT EDIT THIS FILE MANUALLY!
// To update the version number for a new release, run "sampctl package release"

#define %s_VERSION_MAJOR (%d)
#define %s_VERSION_MINOR (%d)
#define %s_VERSION_PATCH (%d)
`

// Release is an interactive release tool for package versioning
func Release(ctx context.Context, gh *github.Client, auth transport.AuthMethod, pkg pawnpackage.Package) (err error) {
	repo, err := git.PlainOpen(pkg.LocalPath)
	if err != nil {
		return errors.Wrap(err, "failed to read package as git repository")
	}

	_, err = repo.Head()
	if err != nil {
		print.Erro("failed to get repo HEAD reference, if this is a new repo, you need to make at least one commit")
		return
	}

	tags, err := versioning.GetRepoSemverTags(repo)
	if err != nil {
		return errors.Wrap(err, "failed to get semver tags")
	}
	sort.Sort(sort.Reverse(tags))

	var questions []*survey.Question
	var answers struct {
		Version      string
		Generate     bool
		Distribution bool
		GitHub       bool
	}

	if len(tags) == 0 {
		questions = []*survey.Question{
			{
				Name: "Version",
				Prompt: &survey.Select{
					Message: "New Project Version",
					Options: []string{
						"0.0.1: Unstable prototype",
						"0.1.0: Stable prototype but subject to change",
						"1.0.0: Stable release, API won't change",
						"x.y.z: Enter a custom initial version",
					},
				},
				Validate: survey.Required,
			},
		}
	} else {
		latest := tags[0]

		print.Info("Latest version:", latest.Version)

		bumpPatch := latest.Version.IncPatch()
		bumpMinor := latest.Version.IncMinor()
		bumpMajor := latest.Version.IncMajor()

		questions = []*survey.Question{
			{
				Name: "Version",
				Prompt: &survey.Select{
					Message: "Select Version Bump",
					Options: []string{
						fmt.Sprintf("%s: I made backwards-compatible bug fixes", bumpPatch.String()),
						fmt.Sprintf("%s: I added functionality in a backwards-compatible manner", bumpMinor.String()),
						fmt.Sprintf("%s: I made incompatible API changes", bumpMajor.String()),
					},
				},
				Validate: survey.Required,
			},
		}
	}

	questions = append(questions, &survey.Question{
		Name: "Generate",
		Prompt: &survey.Confirm{
			Message: fmt.Sprintf("Generate/update `%s`?", packageSlug(pkg.Repo)+"_version.inc"),
			Default: true,
		},
	})

	// questions = append(questions, &survey.Question{
	// 	Name: "Distribution",
	// 	Prompt: &survey.Confirm{
	// 		Message: "Create Distribution Release?",
	// 		Default: false,
	// 	},
	// })

	questions = append(questions, &survey.Question{
		Name: "GitHub",
		Prompt: &survey.Confirm{
			Message: "Create GitHub Release? (requires `github_token` token to be set in `~/.samp/config.json`)",
			Default: false,
		},
	})

	err = survey.Ask(questions, &answers)
	if err != nil {
		return errors.Wrap(err, "failed to open wizard")
	}
	versionText := strings.Split(answers.Version, ":")[0]

	if versionText == "x.y.z" {
		var custom struct{ Custom string }
		err = survey.Ask([]*survey.Question{{
			Name: "Custom",
			Prompt: &survey.Input{
				Message: "Enter custom semantic version number",
				Default: "0.1.0",
			},
			Validate: func(ans interface{}) (err error) {
				if _, err = semver.NewVersion(ans.(string)); err != nil {
					return err
				}
				return
			},
		}}, &custom)
		if err != nil {
			return errors.Wrap(err, "failed to open wizard")
		}
		versionText = custom.Custom
	}

	newVersion, err := semver.NewVersion(versionText)
	if err != nil {
		return errors.Wrap(err, "failed to create version from result")
	}

	print.Info("New version:", newVersion)

	wt, err := repo.Worktree()
	if err != nil {
		return errors.Wrap(err, "failed to get worktree")
	}

	status, err := wt.Status()
	if err != nil {
		return errors.Wrap(err, "failed to get worktree status")
	}

	if !status.IsClean() {
		return errors.New("working directory has uncommitted changes, please commit or stash them first")
	}

	var versionFile string
	if answers.Generate {
		versionFile, err = generateVersionInc(pkg, newVersion)
		if err != nil {
			return errors.Wrap(err, "failed to generate version.inc")
		}

		_, err = wt.Add(versionFile)
		if err != nil {
			return errors.Wrap(err, "failed to add versionfile to worktree")
		}
	}

	hash, err := wt.Commit("sampctl package release: "+newVersion.String(), &git.CommitOptions{
		Author: &object.Signature{
			Name:  "sampctl",
			Email: "null",
			When:  time.Now(),
		},
	})
	if err != nil {
		return errors.Wrap(err, "failed to create new commit for release")
	}
	refName := plumbing.ReferenceName("refs/tags/" + newVersion.String())
	ref := plumbing.NewHashReference(refName, hash)
	err = repo.Storer.SetReference(ref)
	if err != nil {
		return
	}

	head, err := repo.Head()
	if err != nil {
		return errors.Wrap(err, "failed to get HEAD reference")
	}
	branchName := head.Name().Short()

	print.Info("Pushing commit and tag", newVersion, "to remote")
	err = repo.Push(&git.PushOptions{
		RefSpecs: []config.RefSpec{
			config.RefSpec("refs/heads/" + branchName + ":refs/heads/" + branchName),
			config.RefSpec("refs/tags/*:refs/tags/*"),
		},
		Auth: auth,
	})
	if err != nil {
		if err.Error() == "authentication required" {
			configPath := filepath.Join(util.GetConfigDir(), "config.json")
			print.Erro("Git authentication failed. Options:")
			print.Erro("  1. Set up SSH keys: ssh-keygen && ssh-add ~/.ssh/id_rsa")
			print.Erro("  2. Add git credentials to:", configPath)
			print.Erro("     {\"git_username\": \"your-username\", \"git_password\": \"your-token\"}")
			return errors.New("git authentication required")
		} else if err.Error() == "already up-to-date" {
			err = nil
		} else {
			return errors.Wrap(err, "failed to push to remote")
		}
	}

	if answers.GitHub {
		if pkg.User == "" || pkg.Repo == "" {
			return errors.New("user and repo fields must be set in pawn.json to create GitHub releases\nAdd: \"user\": \"your-github-username\" and \"repo\": \"your-repo-name\"")
		}

		changelog, err := generateChangelog(repo, tags, newVersion)
		if err != nil {
			print.Warn("Failed to generate changelog:", err)
			changelog = fmt.Sprintf("Release %s", newVersion.String())
		}

		archivePath, err := createReleaseArchive(pkg, newVersion)
		if err != nil {
			print.Warn("Failed to create release archive:", err)
		}

		print.Info("Creating release for", newVersion)
		versionString := newVersion.String()
		release, _, err := gh.Repositories.CreateRelease(ctx, pkg.User, pkg.Repo, &github.RepositoryRelease{
			TagName: &versionString,
			Name:    &versionString,
			Body:    &changelog,
			Draft:   &[]bool{true}[0],
		})
		if err != nil {
			configPath := filepath.Join(util.GetConfigDir(), "config.json")
			print.Erro("Failed to create GitHub release. Please ensure:")
			print.Erro("  1. You have a valid GitHub API token set in:", configPath)
			print.Erro("     {\"github_token\": \"your-github-token\"}")
			print.Erro("  2. The token has 'repo' scope permissions")
			print.Erro("  3. You have write access to", pkg.User+"/"+pkg.Repo)
			return errors.Wrap(err, "failed to create GitHub release")
		}

		if archivePath != "" && release != nil {
			print.Info("Uploading release archive...")
			err = uploadReleaseAsset(ctx, gh, pkg, release, archivePath)
			if err != nil {
				print.Warn("Failed to upload release asset:", err)
			} else {
				print.Info("Release archive uploaded successfully")
			}
		}

		print.Info("Released at:", fmt.Sprintf("https://github.com/%s/%s/releases", pkg.User, pkg.Repo))
	}

	return nil
}

func generateVersionInc(pkg pawnpackage.Package, version *semver.Version) (filename string, err error) {
	filename = packageSlug(pkg.Repo) + "_version.inc"
	err = ioutil.WriteFile(
		filepath.Join(pkg.LocalPath, filename),
		[]byte(generateVersionIncString(pkg.Repo, version)),
		0o600,
	)
	return
}

func generateVersionIncString(name string, version *semver.Version) (result string) {
	packageName := strings.ToUpper(packageSlug(name))
	result = fmt.Sprintf(versionIncTemplate,
		packageName,
		version.Major(),
		packageName,
		version.Minor(),
		packageName,
		version.Patch(),
	)
	return
}

func packageSlug(name string) (slug string) {
	replacer := strings.NewReplacer(
		"-", "_",
		".", "_",
	)
	return replacer.Replace(name)
}

// generateChangelog creates a changelog from git commits between the last tag and HEAD
func generateChangelog(repo *git.Repository, tags versioning.VersionedTags, newVersion *semver.Version) (string, error) {
	var fromHash plumbing.Hash
	var fromVersion string

	if len(tags) > 0 {
		sort.Sort(sort.Reverse(tags))
		fromHash = tags[0].Ref.Hash()
		fromVersion = tags[0].Version.String()
	}

	head, err := repo.Head()
	if err != nil {
		return "", errors.Wrap(err, "failed to get HEAD")
	}

	var changelog strings.Builder
	if fromVersion != "" {
		changelog.WriteString(fmt.Sprintf("## Changes since %s\n\n", fromVersion))
	} else {
		changelog.WriteString("## Initial Release\n\n")
	}

	commits, err := repo.Log(&git.LogOptions{
		From: head.Hash(),
	})
	if err != nil {
		return "", errors.Wrap(err, "failed to get commit log")
	}
	defer commits.Close()

	var changesList []string
	err = commits.ForEach(func(c *object.Commit) error {
		if fromHash != plumbing.ZeroHash && c.Hash == fromHash {
			return storer.ErrStop
		}

		message := strings.TrimSpace(c.Message)
		if strings.HasPrefix(message, "Merge ") || strings.HasPrefix(message, "sampctl package release:") {
			return nil
		}

		firstLine := strings.Split(message, "\n")[0]
		if len(firstLine) > 80 {
			firstLine = firstLine[:77] + "..."
		}

		changesList = append(changesList, fmt.Sprintf("- %s", firstLine))
		return nil
	})
	if err != nil && err != storer.ErrStop {
		return "", errors.Wrap(err, "failed to iterate commits")
	}

	if len(changesList) == 0 {
		changelog.WriteString("No significant changes.\n")
	} else {
		for _, change := range changesList {
			changelog.WriteString(change + "\n")
		}
	}

	return changelog.String(), nil
}

// createReleaseArchive creates a ZIP archive containing the package's include files
func createReleaseArchive(pkg pawnpackage.Package, version *semver.Version) (string, error) {
	archiveName := fmt.Sprintf("%s-%s.zip", pkg.Repo, version.String())
	archivePath := filepath.Join(pkg.LocalPath, archiveName)

	archiveFile, err := os.Create(archivePath)
	if err != nil {
		return "", errors.Wrap(err, "failed to create archive file")
	}
	defer archiveFile.Close()

	zipWriter := zip.NewWriter(archiveFile)
	defer zipWriter.Close()

	includePath := pkg.IncludePath
	if includePath == "" {
		includePath = "."
	}

	fullIncludePath := filepath.Join(pkg.LocalPath, includePath)

	err = filepath.Walk(fullIncludePath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if info.IsDir() {
			return nil
		}

		ext := strings.ToLower(filepath.Ext(path))
		baseName := strings.ToLower(info.Name())

		if !(ext == ".inc" || ext == ".pwn" ||
			baseName == "readme.md" || baseName == "readme.txt" ||
			baseName == "license" || baseName == "license.md" || baseName == "license.txt" ||
			strings.HasSuffix(baseName, "_version.inc")) {
			return nil
		}

		relPath, err := filepath.Rel(pkg.LocalPath, path)
		if err != nil {
			return err
		}

		zipPath := filepath.Join("pawno", "include", relPath)

		zipPath = strings.ReplaceAll(zipPath, "\\", "/")

		writer, err := zipWriter.Create(zipPath)
		if err != nil {
			return errors.Wrap(err, "failed to create zip entry")
		}

		file, err := os.Open(path)
		if err != nil {
			return errors.Wrap(err, "failed to open source file")
		}
		defer file.Close()

		_, err = io.Copy(writer, file)
		if err != nil {
			return errors.Wrap(err, "failed to write file to archive")
		}

		return nil
	})
	if err != nil {
		os.Remove(archivePath)
		return "", errors.Wrap(err, "failed to create archive contents")
	}

	print.Info("Created release archive:", archiveName)
	return archivePath, nil
}

// uploadReleaseAsset uploads the release archive as an asset to the GitHub release
func uploadReleaseAsset(ctx context.Context, gh *github.Client, pkg pawnpackage.Package, release *github.RepositoryRelease, archivePath string) error {
	file, err := os.Open(archivePath)
	if err != nil {
		return errors.Wrap(err, "failed to open archive file")
	}
	defer file.Close()

	fileInfo, err := file.Stat()
	if err != nil {
		return errors.Wrap(err, "failed to stat archive file")
	}

	archiveName := filepath.Base(archivePath)
	opts := &github.UploadOptions{
		Name: archiveName,
	}

	_, _, err = gh.Repositories.UploadReleaseAsset(ctx, pkg.User, pkg.Repo, *release.ID, opts, file)
	if err != nil {
		return errors.Wrap(err, "failed to upload release asset")
	}

	print.Info("Uploaded", archiveName, "size:", formatBytes(fileInfo.Size()))
	return nil
}

// formatBytes formats a byte count into a human-readable string
func formatBytes(bytes int64) string {
	const unit = 1024
	if bytes < unit {
		return fmt.Sprintf("%d B", bytes)
	}
	div, exp := int64(unit), 0
	for n := bytes / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %ciB", float64(bytes)/float64(div), "KMGTPE"[exp])
}
